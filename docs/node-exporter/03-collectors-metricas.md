# M√≥dulo 03: Collectors e M√©tricas

> **Dom√≠nio completo** - Explore todos os collectors dispon√≠veis e suas m√©tricas espec√≠ficas

## üìã Objetivos do M√≥dulo

Ao final deste m√≥dulo, voc√™ ser√° capaz de:
- ‚úÖ **Compreender** todos os collectors dispon√≠veis no Node Exporter
- ‚úÖ **Configurar** collectors espec√≠ficos para diferentes cen√°rios
- ‚úÖ **Filtrar** m√©tricas usando exclus√µes e inclus√µes
- ‚úÖ **Customizar** coleta de m√©tricas via TextFile Collector
- ‚úÖ **Otimizar** performance atrav√©s de sele√ß√£o de collectors

## üîç Vis√£o Geral dos Collectors

O Node Exporter possui mais de 30 collectors diferentes, cada um especializado em coletar m√©tricas espec√≠ficas do sistema. Eles s√£o divididos em categorias:

### üìä Collectors por Categoria

```mermaid
graph TB
    subgraph "Core Collectors (Sempre Habilitados)"
        CPU["CPU"]
        MEM["Memory"]
        DISK["Disk"]
        NET["Network"]
        FS["Filesystem"]
        LOAD["Load Average"]
        TIME["Time"]
        UNAME["System Info"]
    end
    
    subgraph "System Collectors"
        SYSTEMD["Systemd"]
        PROC["Processes"]
        INTER["Interrupts"]
        SCHED["Scheduler"]
        SOCK["Sockets"]
    end
    
    subgraph "Hardware Collectors"
        HWMON["Hardware Monitor"]
        THERMAL["Thermal"]
        POWER["Power Supply"]
        RAPL["RAPL Energy"]
    end
    
    subgraph "Network Collectors"
        NETDEV["Network Devices"]
        NETSTAT["Network Statistics"]
        CONNTRACK["Connection Tracking"]
        ARP["ARP Table"]
    end
    
    subgraph "Storage Collectors"
        BTRFS["Btrfs"]
        ZFS["ZFS"]
        XFS["XFS"]
        MDADM["Software RAID"]
        NVME["NVMe"]
    end
    
    subgraph "Custom Collectors"
        TEXTFILE["TextFile"]
        SCRIPT["Script Execution"]
    end
```

## üñ•Ô∏è Core Collectors (Habilitados por Padr√£o)

### 1. CPU Collector

**M√©tricas Principais:**
```promql
# Tempo de CPU por modo e core
node_cpu_seconds_total{cpu="0", mode="user"}
node_cpu_seconds_total{cpu="0", mode="system"}
node_cpu_seconds_total{cpu="0", mode="idle"}
node_cpu_seconds_total{cpu="0", mode="iowait"}
node_cpu_seconds_total{cpu="0", mode="irq"}
node_cpu_seconds_total{cpu="0", mode="softirq"}
node_cpu_seconds_total{cpu="0", mode="steal"}
node_cpu_seconds_total{cpu="0", mode="nice"}

# Informa√ß√µes de CPU
node_cpu_info{cpu="0", core="0", package="0"}
```

**Configura√ß√£o:**
```bash
# Habilitar coleta de informa√ß√µes detalhadas de CPU
node_exporter --collector.cpu.info

# Desabilitar se necess√°rio (n√£o recomendado)
node_exporter --no-collector.cpu
```

**Queries √öteis:**
```promql
# CPU Usage por core
100 - (avg by (instance, cpu) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# CPU Usage total
100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# CPU I/O Wait
avg by (instance) (irate(node_cpu_seconds_total{mode="iowait"}[5m])) * 100

# CPU Steal (importante em VMs)
avg by (instance) (irate(node_cpu_seconds_total{mode="steal"}[5m])) * 100
```

### 2. Memory Collector

**M√©tricas Principais:**
```promql
# Mem√≥ria b√°sica
node_memory_MemTotal_bytes
node_memory_MemFree_bytes
node_memory_MemAvailable_bytes
node_memory_Buffers_bytes
node_memory_Cached_bytes

# Swap
node_memory_SwapTotal_bytes
node_memory_SwapFree_bytes
node_memory_SwapCached_bytes

# Mem√≥ria detalhada
node_memory_Active_bytes
node_memory_Inactive_bytes
node_memory_Dirty_bytes
node_memory_Writeback_bytes
node_memory_Slab_bytes
node_memory_PageTables_bytes
node_memory_VmallocUsed_bytes
```

**Queries √öteis:**
```promql
# Memory Usage percentage
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100

# Swap Usage percentage
(1 - (node_memory_SwapFree_bytes / node_memory_SwapTotal_bytes)) * 100

# Buffer/Cache Usage
(node_memory_Buffers_bytes + node_memory_Cached_bytes) / node_memory_MemTotal_bytes * 100

# Memory pressure (dirty pages)
node_memory_Dirty_bytes / node_memory_MemTotal_bytes * 100
```

### 3. Disk Collector

**M√©tricas Principais:**
```promql
# I/O Operations
node_disk_reads_completed_total{device="sda"}
node_disk_writes_completed_total{device="sda"}
node_disk_read_bytes_total{device="sda"}
node_disk_written_bytes_total{device="sda"}

# I/O Timing
node_disk_read_time_seconds_total{device="sda"}
node_disk_write_time_seconds_total{device="sda"}
node_disk_io_time_seconds_total{device="sda"}
node_disk_io_time_weighted_seconds_total{device="sda"}

# Queue depth
node_disk_reads_merged_total{device="sda"}
node_disk_writes_merged_total{device="sda"}
```

**Configura√ß√£o:**
```bash
# Excluir dispositivos espec√≠ficos
node_exporter --collector.diskstats.ignored-devices="^(ram|loop|fd|(h|s|v|xv)d[a-z]|nvme\\d+n\\d+p)\\d+$"

# Incluir apenas dispositivos espec√≠ficos
node_exporter --collector.diskstats.device-include="^(sda|sdb|nvme0n1)$"
```

**Queries √öteis:**
```promql
# Disk IOPS
rate(node_disk_reads_completed_total[5m]) + rate(node_disk_writes_completed_total[5m])

# Disk Throughput (MB/s)
(rate(node_disk_read_bytes_total[5m]) + rate(node_disk_written_bytes_total[5m])) / 1024 / 1024

# Disk Utilization %
rate(node_disk_io_time_seconds_total[5m]) * 100

# Average I/O time
rate(node_disk_io_time_weighted_seconds_total[5m]) / rate(node_disk_reads_completed_total[5m] + node_disk_writes_completed_total[5m])
```

### 4. Network Collector

**M√©tricas Principais:**
```promql
# Tr√°fego de rede
node_network_receive_bytes_total{device="eth0"}
node_network_transmit_bytes_total{device="eth0"}
node_network_receive_packets_total{device="eth0"}
node_network_transmit_packets_total{device="eth0"}

# Erros e drops
node_network_receive_errs_total{device="eth0"}
node_network_transmit_errs_total{device="eth0"}
node_network_receive_drop_total{device="eth0"}
node_network_transmit_drop_total{device="eth0"}

# Estado da interface
node_network_up{device="eth0"}
node_network_carrier{device="eth0"}
node_network_mtu_bytes{device="eth0"}
node_network_speed_bytes{device="eth0"}
```

**Configura√ß√£o:**
```bash
# Excluir interfaces virtuais
node_exporter --collector.netdev.device-exclude="^(veth.*|docker.*|br-.*|lo)$"

# Incluir apenas interfaces f√≠sicas
node_exporter --collector.netdev.device-include="^(eth|ens|enp).*$"
```

### 5. Filesystem Collector

**M√©tricas Principais:**
```promql
# Espa√ßo em disco
node_filesystem_size_bytes{mountpoint="/"}
node_filesystem_free_bytes{mountpoint="/"}
node_filesystem_avail_bytes{mountpoint="/"}

# Inodes
node_filesystem_files{mountpoint="/"}
node_filesystem_files_free{mountpoint="/"}

# Estado do filesystem
node_filesystem_readonly{mountpoint="/"}
node_filesystem_device_error{mountpoint="/"}
```

**Configura√ß√£o:**
```bash
# Excluir filesystems tempor√°rios
node_exporter --collector.filesystem.mount-points-exclude="^/(dev|proc|sys|var/lib/docker/.+)($|/)"

# Excluir tipos de filesystem
node_exporter --collector.filesystem.fs-types-exclude="^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$"
```

## ‚öôÔ∏è System Collectors

### 1. Systemd Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.systemd
```

**M√©tricas:**
```promql
# Estado dos servi√ßos
node_systemd_unit_state{name="nginx.service", state="active"}
node_systemd_unit_state{name="nginx.service", state="inactive"}
node_systemd_unit_state{name="nginx.service", state="failed"}

# Tempo de inicializa√ß√£o
node_systemd_service_restart_total{name="nginx.service"}
node_systemd_socket_accepted_connections_total{name="docker.socket"}

# Informa√ß√µes do sistema
node_systemd_system_running
node_systemd_version
```

**Configura√ß√£o Avan√ßada:**
```bash
# Filtrar apenas servi√ßos espec√≠ficos
node_exporter --collector.systemd --collector.systemd.unit-whitelist="(sshd|nginx|mysql|postgresql)\.service"

# Incluir sockets e timers
node_exporter --collector.systemd --collector.systemd.enable-task-metrics --collector.systemd.enable-restarts-metrics --collector.systemd.enable-start-time-metrics
```

**Script de Configura√ß√£o:**
```bash
#!/bin/bash
# configure-systemd-collector.sh

# Criar lista de servi√ßos cr√≠ticos para monitorar
CRITICAL_SERVICES=(
    "sshd.service"
    "nginx.service"
    "apache2.service"
    "mysql.service"
    "postgresql.service"
    "redis.service"
    "docker.service"
    "kubelet.service"
)

# Gerar whitelist
WHITELIST=$(IFS='|'; echo "(${CRITICAL_SERVICES[*]})\.service")

echo "Configura√ß√£o do Systemd Collector:"
echo "--collector.systemd"
echo "--collector.systemd.unit-whitelist=\"$WHITELIST\""
echo "--collector.systemd.enable-task-metrics"
echo "--collector.systemd.enable-restarts-metrics"
echo "--collector.systemd.enable-start-time-metrics"

# Testar se servi√ßos existem
echo "\nServi√ßos encontrados no sistema:"
for service in "${CRITICAL_SERVICES[@]}"; do
    if systemctl list-unit-files | grep -q "^$service"; then
        STATUS=$(systemctl is-active "$service" 2>/dev/null || echo "not-found")
        echo "‚úÖ $service: $STATUS"
    else
        echo "‚ùå $service: n√£o encontrado"
    fi
done
```

### 2. Processes Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.processes
```

**M√©tricas:**
```promql
# Contadores de processos
node_procs_running
node_procs_blocked

# Estados de processos
node_processes_pids
node_processes_threads
node_processes_threads_limit
node_processes_max_processes

# Forks
node_forks_total
```

**Queries √öteis:**
```promql
# Processos em execu√ß√£o
node_procs_running

# Processos bloqueados (I/O wait)
node_procs_blocked

# Taxa de fork
rate(node_forks_total[5m])

# Utiliza√ß√£o de PIDs
node_processes_pids / node_processes_max_processes * 100
```

### 3. Interrupts Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.interrupts
```

**M√©tricas:**
```promql
# Interrup√ß√µes por CPU e tipo
node_intr_total{cpu="0", type="0"}
node_intr_total{cpu="0", type="timer"}
node_intr_total{cpu="0", type="net_tx"}
node_intr_total{cpu="0", type="net_rx"}
```

## üîß Hardware Collectors

### 1. Hardware Monitor (hwmon)

**Habilita√ß√£o:**
```bash
node_exporter --collector.hwmon
```

**M√©tricas:**
```promql
# Temperaturas
node_hwmon_temp_celsius{chip="coretemp-isa-0000", sensor="temp1"}
node_hwmon_temp_max_celsius{chip="coretemp-isa-0000", sensor="temp1"}
node_hwmon_temp_crit_celsius{chip="coretemp-isa-0000", sensor="temp1"}

# Voltagens
node_hwmon_in_volts{chip="acpi-0", sensor="in0"}

# Velocidade de ventiladores
node_hwmon_fan_rpm{chip="nct6775-isa-0290", sensor="fan1"}
```

**Script de Configura√ß√£o:**
```bash
#!/bin/bash
# setup-hwmon-collector.sh

echo "Verificando sensores de hardware dispon√≠veis..."

# Verificar se lm-sensors est√° instalado
if ! command -v sensors &> /dev/null; then
    echo "Instalando lm-sensors..."
    sudo apt-get update && sudo apt-get install -y lm-sensors
fi

# Detectar sensores
echo "Detectando sensores..."
sudo sensors-detect --auto

# Listar sensores dispon√≠veis
echo "Sensores dispon√≠veis:"
sensors

# Verificar arquivos hwmon
echo "\nArquivos hwmon dispon√≠veis:"
find /sys/class/hwmon -name "temp*_input" -o -name "fan*_input" -o -name "in*_input" | head -10

# Testar coleta
echo "\nTestando coleta hwmon..."
node_exporter --collector.hwmon --web.listen-address=":9101" &
NE_PID=$!
sleep 3

if curl -s http://localhost:9101/metrics | grep -q "node_hwmon"; then
    echo "‚úÖ Hardware monitoring funcionando"
    curl -s http://localhost:9101/metrics | grep "node_hwmon" | head -5
else
    echo "‚ùå Nenhuma m√©trica hwmon encontrada"
fi

kill $NE_PID 2>/dev/null
```

### 2. Thermal Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.thermal_zone
```

**M√©tricas:**
```promql
# Temperaturas por zona t√©rmica
node_thermal_zone_temp{type="x86_pkg_temp", zone="0"}
node_thermal_zone_temp{type="acpitz", zone="0"}
```

### 3. Power Supply Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.powersupplyclass
```

**M√©tricas:**
```promql
# Estado da bateria
node_power_supply_online{power_supply="ADP1"}
node_power_supply_present{power_supply="BAT0"}

# Informa√ß√µes da bateria
node_power_supply_capacity{power_supply="BAT0"}
node_power_supply_charge_full{power_supply="BAT0"}
node_power_supply_charge_now{power_supply="BAT0"}
node_power_supply_voltage_now{power_supply="BAT0"}
```

## üåê Network Collectors Avan√ßados

### 1. Network Statistics (netstat)

**Habilita√ß√£o:**
```bash
node_exporter --collector.netstat
```

**M√©tricas:**
```promql
# Estat√≠sticas TCP
node_netstat_Tcp_ActiveOpens
node_netstat_Tcp_PassiveOpens
node_netstat_Tcp_AttemptFails
node_netstat_Tcp_EstabResets
node_netstat_Tcp_CurrEstab
node_netstat_Tcp_InSegs
node_netstat_Tcp_OutSegs
node_netstat_Tcp_RetransSegs

# Estat√≠sticas UDP
node_netstat_Udp_InDatagrams
node_netstat_Udp_OutDatagrams
node_netstat_Udp_InErrors
node_netstat_Udp_NoPorts
```

### 2. Socket Statistics (sockstat)

**Habilita√ß√£o:**
```bash
node_exporter --collector.sockstat
```

**M√©tricas:**
```promql
# Sockets em uso
node_sockstat_sockets_used
node_sockstat_TCP_inuse
node_sockstat_TCP_orphan
node_sockstat_TCP_tw
node_sockstat_TCP_alloc
node_sockstat_TCP_mem
node_sockstat_UDP_inuse
node_sockstat_UDP_mem
```

### 3. Connection Tracking (conntrack)

**Habilita√ß√£o:**
```bash
node_exporter --collector.conntrack
```

**M√©tricas:**
```promql
# Conex√µes rastreadas
node_nf_conntrack_entries
node_nf_conntrack_entries_limit
```

## üíæ Storage Collectors Especializados

### 1. Btrfs Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.btrfs
```

**M√©tricas:**
```promql
# Informa√ß√µes do filesystem Btrfs
node_btrfs_info{label="", uuid="..."}
node_btrfs_allocation_ratio
node_btrfs_global_rsv_size_bytes
node_btrfs_device_size_bytes
```

### 2. ZFS Collector

**Habilita√ß√£o:**
```bash
node_exporter --collector.zfs
```

**M√©tricas:**
```promql
# Estat√≠sticas ZFS
node_zfs_arc_hits_total
node_zfs_arc_misses_total
node_zfs_arc_size_bytes
node_zfs_arc_max_bytes
```

### 3. Software RAID (mdadm)

**Habilita√ß√£o:**
```bash
node_exporter --collector.mdadm
```

**M√©tricas:**
```promql
# Estado do RAID
node_md_state{device="md0", state="active"}
node_md_disks{device="md0", state="active"}
node_md_disks_required{device="md0"}
```

## üìù TextFile Collector (M√©tricas Customizadas)

### Configura√ß√£o B√°sica

```bash
# Habilitar TextFile Collector
node_exporter --collector.textfile.directory=/var/lib/node_exporter/textfile_collector
```

### Script Avan√ßado de M√©tricas Customizadas

```bash
#!/bin/bash
# advanced-custom-metrics.sh

TEXTFILE_DIR="/var/lib/node_exporter/textfile_collector"
METRICS_FILE="$TEXTFILE_DIR/advanced_metrics.prom"
TEMP_FILE="$TEXTFILE_DIR/advanced_metrics.prom.$$"

# Fun√ß√£o para adicionar m√©trica com labels
add_metric_with_labels() {
    local name="$1"
    local value="$2"
    local labels="$3"
    local help="$4"
    local type="$5"
    
    echo "# HELP $name $help" >> "$TEMP_FILE"
    echo "# TYPE $name $type" >> "$TEMP_FILE"
    echo "${name}{${labels}} $value" >> "$TEMP_FILE"
}

# Limpar arquivo tempor√°rio
> "$TEMP_FILE"

# 1. M√©tricas de aplica√ß√£o
echo "# Coletando m√©tricas de aplica√ß√£o..."

# Verificar se Nginx est√° rodando e coletar estat√≠sticas
if systemctl is-active --quiet nginx; then
    # Conex√µes ativas do Nginx (requer stub_status)
    if curl -s http://localhost/nginx_status > /dev/null 2>&1; then
        NGINX_ACTIVE=$(curl -s http://localhost/nginx_status | grep 'Active connections' | awk '{print $3}')
        add_metric_with_labels "custom_nginx_connections_active" "$NGINX_ACTIVE" 'service="nginx"' "Active Nginx connections" "gauge"
        
        NGINX_REQUESTS=$(curl -s http://localhost/nginx_status | awk '/^[[:space:]]*[0-9]+[[:space:]]+[0-9]+[[:space:]]+[0-9]+/ {print $3}')
        add_metric_with_labels "custom_nginx_requests_total" "$NGINX_REQUESTS" 'service="nginx"' "Total Nginx requests" "counter"
    fi
fi

# 2. M√©tricas de banco de dados
echo "# Coletando m√©tricas de banco de dados..."

# MySQL/MariaDB
if systemctl is-active --quiet mysql || systemctl is-active --quiet mariadb; then
    # Conex√µes MySQL (requer usu√°rio com privil√©gios)
    MYSQL_CONNECTIONS=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" 2>/dev/null | awk 'NR==2 {print $2}' || echo "0")
    add_metric_with_labels "custom_mysql_connections" "$MYSQL_CONNECTIONS" 'service="mysql"' "MySQL active connections" "gauge"
    
    MYSQL_QUERIES=$(mysql -e "SHOW STATUS LIKE 'Queries';" 2>/dev/null | awk 'NR==2 {print $2}' || echo "0")
    add_metric_with_labels "custom_mysql_queries_total" "$MYSQL_QUERIES" 'service="mysql"' "MySQL total queries" "counter"
fi

# PostgreSQL
if systemctl is-active --quiet postgresql; then
    PG_CONNECTIONS=$(sudo -u postgres psql -t -c "SELECT count(*) FROM pg_stat_activity;" 2>/dev/null | tr -d ' ' || echo "0")
    add_metric_with_labels "custom_postgresql_connections" "$PG_CONNECTIONS" 'service="postgresql"' "PostgreSQL active connections" "gauge"
fi

# 3. M√©tricas de sistema customizadas
echo "# Coletando m√©tricas de sistema customizadas..."

# Usu√°rios logados por tipo
SSH_USERS=$(who | grep -c 'pts/')
add_metric_with_labels "custom_users_logged_in" "$SSH_USERS" 'type="ssh"' "Users logged in via SSH" "gauge"

CONSOLE_USERS=$(who | grep -c 'tty')
add_metric_with_labels "custom_users_logged_in" "$CONSOLE_USERS" 'type="console"' "Users logged in via console" "gauge"

# Processos por usu√°rio
for user in $(ps -eo user --no-headers | sort | uniq); do
    PROC_COUNT=$(ps -u "$user" --no-headers | wc -l)
    add_metric_with_labels "custom_processes_by_user" "$PROC_COUNT" "user=\"$user\"" "Number of processes by user" "gauge"
done

# 4. M√©tricas de seguran√ßa
echo "# Coletando m√©tricas de seguran√ßa..."

# Tentativas de login falhadas (√∫ltimas 24h)
FAILED_LOGINS=$(journalctl --since "24 hours ago" | grep -c "Failed password" || echo "0")
add_metric_with_labels "custom_security_failed_logins_24h" "$FAILED_LOGINS" 'type="ssh"' "Failed login attempts in last 24h" "gauge"

# Processos suspeitos
SUSPICIOUS_PROCS=$(ps aux | grep -E '(nc|netcat|ncat|socat|telnet)' | grep -v grep | wc -l)
add_metric_with_labels "custom_security_suspicious_processes" "$SUSPICIOUS_PROCS" 'type="network_tools"' "Suspicious network processes" "gauge"

# 5. M√©tricas de performance customizadas
echo "# Coletando m√©tricas de performance..."

# Context switches por segundo (m√©dia dos √∫ltimos 5 minutos)
CTXT_SWITCHES=$(awk '/^ctxt/ {print $2}' /proc/stat)
add_metric_with_labels "custom_context_switches_total" "$CTXT_SWITCHES" '' "Total context switches" "counter"

# Page faults
PAGE_FAULTS_MAJOR=$(awk '/^pgmajfault/ {print $2}' /proc/vmstat 2>/dev/null || echo "0")
PAGE_FAULTS_MINOR=$(awk '/^pgfault/ {print $2}' /proc/vmstat 2>/dev/null || echo "0")
add_metric_with_labels "custom_page_faults_total" "$PAGE_FAULTS_MAJOR" 'type="major"' "Major page faults" "counter"
add_metric_with_labels "custom_page_faults_total" "$PAGE_FAULTS_MINOR" 'type="minor"' "Minor page faults" "counter"

# 6. M√©tricas de rede customizadas
echo "# Coletando m√©tricas de rede customizadas..."

# Conex√µes por estado
for state in ESTABLISHED SYN_SENT SYN_RECV FIN_WAIT1 FIN_WAIT2 TIME_WAIT CLOSE CLOSE_WAIT LAST_ACK LISTEN CLOSING; do
    COUNT=$(ss -ant | grep -c "$state" || echo "0")
    add_metric_with_labels "custom_tcp_connections_by_state" "$COUNT" "state=\"$state\"" "TCP connections by state" "gauge"
done

# Conex√µes por porta (top 10)
ss -tlnp | awk 'NR>1 {split($4,a,":"); port=a[length(a)]; count[port]++} END {for(p in count) print p, count[p]}' | sort -k2 -nr | head -10 | while read port count; do
    add_metric_with_labels "custom_listening_ports" "$count" "port=\"$port\"" "Services listening on ports" "gauge"
done

# 7. M√©tricas de armazenamento customizadas
echo "# Coletando m√©tricas de armazenamento..."

# I/O por processo (top 5)
if command -v iotop &> /dev/null; then
    iotop -b -n 1 -a -o | head -10 | tail -5 | while read line; do
        PID=$(echo "$line" | awk '{print $1}')
        READ_RATE=$(echo "$line" | awk '{print $4}' | sed 's/[^0-9.]//g')
        WRITE_RATE=$(echo "$line" | awk '{print $6}' | sed 's/[^0-9.]//g')
        COMMAND=$(echo "$line" | awk '{print $12}')
        
        if [[ "$READ_RATE" =~ ^[0-9.]+$ ]] && [[ "$WRITE_RATE" =~ ^[0-9.]+$ ]]; then
            add_metric_with_labels "custom_process_io_read_rate" "$READ_RATE" "pid=\"$PID\",command=\"$COMMAND\"" "Process I/O read rate" "gauge"
            add_metric_with_labels "custom_process_io_write_rate" "$WRITE_RATE" "pid=\"$PID\",command=\"$COMMAND\"" "Process I/O write rate" "gauge"
        fi
    done
fi

# 8. M√©tricas de containers (se Docker estiver presente)
if command -v docker &> /dev/null && systemctl is-active --quiet docker; then
    echo "# Coletando m√©tricas de containers..."
    
    # Containers por estado
    for state in running paused restarting exited dead created; do
        COUNT=$(docker ps -a --filter "status=$state" --format "table {{.Names}}" | tail -n +2 | wc -l)
        add_metric_with_labels "custom_docker_containers_by_state" "$COUNT" "state=\"$state\"" "Docker containers by state" "gauge"
    done
    
    # Uso de espa√ßo do Docker
    DOCKER_SIZE=$(docker system df --format "table {{.Size}}" | tail -n +2 | head -1 | sed 's/[^0-9.]//g' || echo "0")
    add_metric_with_labels "custom_docker_space_usage_gb" "$DOCKER_SIZE" '' "Docker space usage in GB" "gauge"
fi

# 9. M√©tricas de certificados SSL
echo "# Coletando m√©tricas de certificados SSL..."

# Verificar certificados em /etc/ssl/certs/
find /etc/ssl/certs/ -name "*.crt" -o -name "*.pem" | while read cert_file; do
    if openssl x509 -in "$cert_file" -noout -dates &>/dev/null; then
        EXPIRY_DATE=$(openssl x509 -in "$cert_file" -noout -enddate | cut -d= -f2)
        EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s 2>/dev/null || echo "0")
        CURRENT_EPOCH=$(date +%s)
        DAYS_TO_EXPIRY=$(( (EXPIRY_EPOCH - CURRENT_EPOCH) / 86400 ))
        
        CERT_NAME=$(basename "$cert_file")
        add_metric_with_labels "custom_ssl_certificate_expiry_days" "$DAYS_TO_EXPIRY" "certificate=\"$CERT_NAME\"" "Days until SSL certificate expiry" "gauge"
    fi
done

# 10. Timestamp da coleta
CURRENT_TIMESTAMP=$(date +%s)
add_metric_with_labels "custom_metrics_collection_timestamp" "$CURRENT_TIMESTAMP" '' "Timestamp of custom metrics collection" "gauge"

# Mover arquivo tempor√°rio para final
mv "$TEMP_FILE" "$METRICS_FILE"

echo "M√©tricas customizadas coletadas com sucesso!"
echo "Arquivo: $METRICS_FILE"
echo "Total de m√©tricas: $(grep -c '^custom_' "$METRICS_FILE")"
```

### Cron Job para M√©tricas Customizadas

```bash
#!/bin/bash
# setup-custom-metrics-cron.sh

SCRIPT_PATH="/usr/local/bin/advanced-custom-metrics.sh"
CRON_USER="node_exporter"

# Copiar script para local apropriado
sudo cp advanced-custom-metrics.sh "$SCRIPT_PATH"
sudo chmod +x "$SCRIPT_PATH"
sudo chown node_exporter:node_exporter "$SCRIPT_PATH"

# Configurar cron job
echo "Configurando cron job para m√©tricas customizadas..."

# Executar a cada 2 minutos
echo "*/2 * * * * $SCRIPT_PATH" | sudo crontab -u "$CRON_USER" -

# Verificar cron job
echo "Cron job configurado:"
sudo crontab -u "$CRON_USER" -l

# Executar uma vez para testar
echo "Executando teste inicial..."
sudo -u "$CRON_USER" "$SCRIPT_PATH"

echo "Configura√ß√£o conclu√≠da!"
echo "M√©tricas customizadas ser√£o coletadas a cada 2 minutos"
echo "Arquivo de m√©tricas: /var/lib/node_exporter/textfile_collector/advanced_metrics.prom"
```

## üéõÔ∏è Configura√ß√µes de Performance

### Configura√ß√£o por Ambiente

```bash
#!/bin/bash
# performance-configs.sh

# Configura√ß√£o para desenvolvimento (m√°ximo de m√©tricas)
DEV_CONFIG="
--collector.systemd \
--collector.processes \
--collector.interrupts \
--collector.tcpstat \
--collector.meminfo_numa \
--collector.hwmon \
--collector.thermal_zone \
--collector.powersupplyclass \
--collector.pressure \
--collector.schedstat \
--collector.sockstat \
--collector.softnet \
--collector.textfile.directory=/var/lib/node_exporter/textfile_collector"

# Configura√ß√£o para produ√ß√£o (balanceada)
PROD_CONFIG="
--collector.systemd \
--collector.systemd.unit-whitelist='(sshd|nginx|mysql|postgresql|redis|docker)\.service' \
--collector.processes \
--collector.hwmon \
--collector.pressure \
--collector.sockstat \
--collector.textfile.directory=/var/lib/node_exporter/textfile_collector \
--no-collector.arp \
--no-collector.bcache \
--no-collector.bonding \
--no-collector.btrfs \
--no-collector.conntrack \
--no-collector.cpufreq \
--no-collector.edac \
--no-collector.entropy \
--no-collector.fibrechannel \
--no-collector.infiniband \
--no-collector.interrupts \
--no-collector.ipvs \
--no-collector.mdadm \
--no-collector.nfs \
--no-collector.nfsd \
--no-collector.nvme \
--no-collector.rapl \
--no-collector.schedstat \
--no-collector.selinux \
--no-collector.softnet \
--no-collector.tcpstat \
--no-collector.thermal_zone \
--no-collector.timex \
--no-collector.udp_queues \
--no-collector.xfs \
--no-collector.zfs"

# Configura√ß√£o m√≠nima (baixo overhead)
MINIMAL_CONFIG="
--no-collector.arp \
--no-collector.bcache \
--no-collector.bonding \
--no-collector.btrfs \
--no-collector.conntrack \
--no-collector.cpufreq \
--no-collector.edac \
--no-collector.entropy \
--no-collector.fibrechannel \
--no-collector.hwmon \
--no-collector.infiniband \
--no-collector.interrupts \
--no-collector.ipvs \
--no-collector.mdadm \
--no-collector.meminfo_numa \
--no-collector.nfs \
--no-collector.nfsd \
--no-collector.nvme \
--no-collector.powersupplyclass \
--no-collector.pressure \
--no-collector.processes \
--no-collector.rapl \
--no-collector.schedstat \
--no-collector.selinux \
--no-collector.sockstat \
--no-collector.softnet \
--no-collector.systemd \
--no-collector.tcpstat \
--no-collector.thermal_zone \
--no-collector.timex \
--no-collector.udp_queues \
--no-collector.xfs \
--no-collector.zfs"

echo "=== Configura√ß√µes de Performance ==="
echo
echo "1. Desenvolvimento (m√°ximo de m√©tricas):"
echo "node_exporter $DEV_CONFIG"
echo
echo "2. Produ√ß√£o (balanceada):"
echo "node_exporter $PROD_CONFIG"
echo
echo "3. M√≠nima (baixo overhead):"
echo "node_exporter $MINIMAL_CONFIG"
```

## üéØ Exerc√≠cio Pr√°tico

### Objetivo
Configurar diferentes collectors e criar m√©tricas customizadas.

### Cen√°rios do Exerc√≠cio

#### Cen√°rio 1: Configura√ß√£o de Collectors por Ambiente

```bash
#!/bin/bash
# exercicio-collectors.sh

echo "=== Exerc√≠cio: Configura√ß√£o de Collectors ==="

# Fun√ß√£o para testar configura√ß√£o
test_config() {
    local config_name="$1"
    local config_args="$2"
    local port="$3"
    
    echo "Testando configura√ß√£o: $config_name"
    echo "Porta: $port"
    
    # Iniciar Node Exporter com configura√ß√£o espec√≠fica
    node_exporter --web.listen-address=":$port" $config_args &
    local pid=$!
    
    # Aguardar inicializa√ß√£o
    sleep 3
    
    # Testar endpoint
    if curl -s "http://localhost:$port/metrics" > /dev/null; then
        echo "‚úÖ Configura√ß√£o $config_name funcionando"
        
        # Contar m√©tricas
        local metric_count=$(curl -s "http://localhost:$port/metrics" | grep -c '^node_')
        echo "üìä Total de m√©tricas: $metric_count"
        
        # Listar collectors ativos
        echo "üîß Collectors ativos:"
        curl -s "http://localhost:$port/metrics" | grep '^node_' | cut -d'_' -f2 | sort | uniq -c | sort -nr | head -10
    else
        echo "‚ùå Erro na configura√ß√£o $config_name"
    fi
    
    # Parar Node Exporter
    kill $pid 2>/dev/null
    wait $pid 2>/dev/null
    echo
}

# Teste 1: Configura√ß√£o m√≠nima
test_config "M√≠nima" "--no-collector.systemd --no-collector.processes --no-collector.interrupts" "9101"

# Teste 2: Configura√ß√£o padr√£o
test_config "Padr√£o" "" "9102"

# Teste 3: Configura√ß√£o completa
test_config "Completa" "--collector.systemd --collector.processes --collector.interrupts --collector.tcpstat" "9103"

echo "Exerc√≠cio de collectors conclu√≠do!"
```

#### Cen√°rio 2: M√©tricas Customizadas

```bash
#!/bin/bash
# exercicio-custom-metrics.sh

echo "=== Exerc√≠cio: M√©tricas Customizadas ==="

# Criar diret√≥rio para TextFile Collector
TEXTFILE_DIR="./textfile_collector"
mkdir -p "$TEXTFILE_DIR"

# Script para gerar m√©tricas de exemplo
cat > generate_custom_metrics.sh << 'EOF'
#!/bin/bash
TEXTFILE_DIR="./textfile_collector"
METRICS_FILE="$TEXTFILE_DIR/example_metrics.prom"

# Limpar arquivo
> "$METRICS_FILE"

# M√©trica 1: N√∫mero de arquivos no diret√≥rio atual
FILE_COUNT=$(ls -1 | wc -l)
echo "# HELP example_files_in_directory Number of files in current directory" >> "$METRICS_FILE"
echo "# TYPE example_files_in_directory gauge" >> "$METRICS_FILE"
echo "example_files_in_directory $FILE_COUNT" >> "$METRICS_FILE"

# M√©trica 2: Uso de CPU (simulado)
CPU_USAGE=$(( RANDOM % 100 ))
echo "# HELP example_cpu_usage_percent Simulated CPU usage percentage" >> "$METRICS_FILE"
echo "# TYPE example_cpu_usage_percent gauge" >> "$METRICS_FILE"
echo "example_cpu_usage_percent $CPU_USAGE" >> "$METRICS_FILE"

# M√©trica 3: Contador de execu√ß√µes
COUNTER_FILE="./execution_counter"
if [ -f "$COUNTER_FILE" ]; then
    COUNTER=$(cat "$COUNTER_FILE")
else
    COUNTER=0
fi
COUNTER=$((COUNTER + 1))
echo $COUNTER > "$COUNTER_FILE"

echo "# HELP example_script_executions_total Total script executions" >> "$METRICS_FILE"
echo "# TYPE example_script_executions_total counter" >> "$METRICS_FILE"
echo "example_script_executions_total $COUNTER" >> "$METRICS_FILE"

# M√©trica 4: Timestamp da √∫ltima execu√ß√£o
TIMESTAMP=$(date +%s)
echo "# HELP example_last_execution_timestamp Timestamp of last execution" >> "$METRICS_FILE"
echo "# TYPE example_last_execution_timestamp gauge" >> "$METRICS_FILE"
echo "example_last_execution_timestamp $TIMESTAMP" >> "$METRICS_FILE"

echo "M√©tricas customizadas geradas: $METRICS_FILE"
EOF

chmod +x generate_custom_metrics.sh

# Gerar m√©tricas iniciais
./generate_custom_metrics.sh

# Mostrar conte√∫do das m√©tricas
echo "Conte√∫do das m√©tricas customizadas:"
cat "$TEXTFILE_DIR/example_metrics.prom"
echo

# Iniciar Node Exporter com TextFile Collector
echo "Iniciando Node Exporter com TextFile Collector..."
node_exporter --collector.textfile.directory="$TEXTFILE_DIR" --web.listen-address=":9104" &
NE_PID=$!

# Aguardar inicializa√ß√£o
sleep 3

# Verificar se m√©tricas customizadas est√£o sendo coletadas
echo "Verificando m√©tricas customizadas:"
if curl -s http://localhost:9104/metrics | grep -q "example_"; then
    echo "‚úÖ M√©tricas customizadas encontradas:"
    curl -s http://localhost:9104/metrics | grep "example_"
else
    echo "‚ùå M√©tricas customizadas n√£o encontradas"
fi

echo
echo "Gerando novas m√©tricas..."
./generate_custom_metrics.sh

echo "Aguardando pr√≥xima coleta..."
sleep 5

echo "Verificando m√©tricas atualizadas:"
curl -s http://localhost:9104/metrics | grep "example_script_executions_total"

# Limpeza
kill $NE_PID 2>/dev/null
rm -rf "$TEXTFILE_DIR" generate_custom_metrics.sh execution_counter

echo "Exerc√≠cio de m√©tricas customizadas conclu√≠do!"
```

#### Cen√°rio 3: An√°lise de Performance

```bash
#!/bin/bash
# exercicio-performance.sh

echo "=== Exerc√≠cio: An√°lise de Performance ==="

# Fun√ß√£o para medir performance
measure_performance() {
    local config_name="$1"
    local config_args="$2"
    local port="$3"
    
    echo "Medindo performance: $config_name"
    
    # Iniciar Node Exporter
    node_exporter --web.listen-address=":$port" $config_args &
    local pid=$!
    
    # Aguardar inicializa√ß√£o
    sleep 3
    
    # Medir tempo de resposta
    local start_time=$(date +%s%N)
    curl -s "http://localhost:$port/metrics" > /dev/null
    local end_time=$(date +%s%N)
    local response_time=$(( (end_time - start_time) / 1000000 ))
    
    # Contar m√©tricas
    local metric_count=$(curl -s "http://localhost:$port/metrics" | grep -c '^node_')
    
    # Medir uso de CPU do processo
    local cpu_usage=$(ps -p $pid -o %cpu --no-headers | tr -d ' ')
    
    # Medir uso de mem√≥ria
    local mem_usage=$(ps -p $pid -o rss --no-headers | tr -d ' ')
    
    echo "üìä Resultados para $config_name:"
    echo "   Tempo de resposta: ${response_time}ms"
    echo "   N√∫mero de m√©tricas: $metric_count"
    echo "   CPU usage: ${cpu_usage}%"
    echo "   Memory usage: ${mem_usage}KB"
    
    # Parar Node Exporter
    kill $pid 2>/dev/null
    wait $pid 2>/dev/null
    echo
}

# Teste diferentes configura√ß√µes
measure_performance "M√≠nima" "--no-collector.systemd --no-collector.processes" "9105"
measure_performance "Padr√£o" "" "9106"
measure_performance "M√°xima" "--collector.systemd --collector.processes --collector.interrupts --collector.tcpstat --collector.hwmon" "9107"

echo "An√°lise de performance conclu√≠da!"
```

### Script Principal do Exerc√≠cio

```bash
#!/bin/bash
# exercicio-completo-collectors.sh

echo "üéØ Exerc√≠cio Completo: Collectors e M√©tricas"
echo "==========================================="

PS3="Escolha um exerc√≠cio: "
options=("Configura√ß√£o de Collectors" "M√©tricas Customizadas" "An√°lise de Performance" "Todos" "Sair")

select opt in "${options[@]}"; do
    case $opt in
        "Configura√ß√£o de Collectors")
            source exercicio-collectors.sh
            ;;
        "M√©tricas Customizadas")
            source exercicio-custom-metrics.sh
            ;;
        "An√°lise de Performance")
            source exercicio-performance.sh
            ;;
        "Todos")
            source exercicio-collectors.sh
            echo
            source exercicio-custom-metrics.sh
            echo
            source exercicio-performance.sh
            ;;
        "Sair")
            break
            ;;
        *) echo "Op√ß√£o inv√°lida $REPLY";;
    esac
done

echo "Exerc√≠cios conclu√≠dos! üéâ"
```

### Valida√ß√£o do Exerc√≠cio

‚úÖ **Crit√©rios de Sucesso:**

1. **Collectors**: Diferentes configura√ß√µes funcionando
2. **M√©tricas**: Contagem correta por configura√ß√£o
3. **Customiza√ß√£o**: TextFile Collector operacional
4. **Performance**: Medi√ß√µes de tempo e recursos
5. **Filtros**: Exclus√µes e inclus√µes aplicadas
6. **An√°lise**: Compara√ß√£o entre configura√ß√µes

## üìù Resumo do M√≥dulo

### Conceitos Aprendidos

‚úÖ **Collectors Principais**
- Core collectors (CPU, Memory, Disk, Network, Filesystem)
- System collectors (Systemd, Processes, Interrupts)
- Hardware collectors (hwmon, thermal, power)
- Network collectors (netstat, sockstat, conntrack)
- Storage collectors (btrfs, zfs, mdadm)

‚úÖ **Configura√ß√£o Avan√ßada**
- Habilita√ß√£o/desabilita√ß√£o seletiva
- Filtros e exclus√µes por regex
- Configura√ß√µes por ambiente
- Otimiza√ß√£o de performance

‚úÖ **M√©tricas Customizadas**
- TextFile Collector
- Scripts de coleta automatizada
- M√©tricas de aplica√ß√£o
- Integra√ß√£o com cron

‚úÖ **Performance e Otimiza√ß√£o**
- Sele√ß√£o de collectors por cen√°rio
- Medi√ß√£o de overhead
- Configura√ß√µes balanceadas
- Troubleshooting de performance

### Pr√≥ximos Passos

üéØ **No pr√≥ximo m√≥dulo** voc√™ aprender√°:
- Integra√ß√£o completa com Prometheus
- Service discovery autom√°tico
- Configura√ß√£o de scraping
- Queries PromQL avan√ßadas
- Alertas baseados em m√©tricas

---

## üß≠ Navega√ß√£o

‚¨ÖÔ∏è **[Anterior: 02 - Instala√ß√£o e Configura√ß√£o](02-instalacao-configuracao.md)**

‚û°Ô∏è **[Pr√≥ximo: 04 - Integra√ß√£o com Prometheus](04-integracao-prometheus.md)**

‚¨ÜÔ∏è **[Voltar ao README Principal](README.md)**

---

> üí° **Dica:** Experimente diferentes combina√ß√µes de collectors para encontrar o equil√≠brio ideal entre informa√ß√£o e performance para seu ambiente espec√≠fico!