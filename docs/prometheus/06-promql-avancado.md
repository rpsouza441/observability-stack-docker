# üöÄ M√ìDULO 06: PROMQL AVAN√áADO

> **Objetivo:** Dominar t√©cnicas avan√ßadas de PromQL para an√°lises complexas  
> **Dura√ß√£o:** 120 minutos  
> **N√≠vel:** Avan√ßado

---

## üéØ O QUE VOC√ä VAI APRENDER

Neste m√≥dulo voc√™ ir√°:
- ‚úÖ Usar fun√ß√µes avan√ßadas de agrega√ß√£o temporal
- ‚úÖ Implementar joins e opera√ß√µes entre m√©tricas
- ‚úÖ Dominar fun√ß√µes de predi√ß√£o e an√°lise
- ‚úÖ Criar queries complexas para troubleshooting
- ‚úÖ Otimizar performance de queries

---

## ‚è∞ FUN√á√ïES DE AGREGA√á√ÉO TEMPORAL

### **üìä Fun√ß√µes _over_time**

```promql
# AVG_OVER_TIME - M√©dia no per√≠odo
avg_over_time(node_load1[1h])
avg_over_time(http_request_duration_seconds[5m])

# MAX_OVER_TIME - M√°ximo no per√≠odo
max_over_time(node_cpu_seconds_total[1h])
max_over_time(http_requests_total[5m])

# MIN_OVER_TIME - M√≠nimo no per√≠odo
min_over_time(node_memory_MemAvailable_bytes[1h])
min_over_time(http_request_duration_seconds[5m])

# SUM_OVER_TIME - Soma no per√≠odo
sum_over_time(increase(http_requests_total[1m])[1h:])

# COUNT_OVER_TIME - Contagem de pontos
count_over_time(up[1h])
count_over_time(node_load1[5m])

# STDDEV_OVER_TIME - Desvio padr√£o
stddev_over_time(node_load1[1h])
stddev_over_time(http_request_duration_seconds[5m])

# STDVAR_OVER_TIME - Vari√¢ncia
stdvar_over_time(node_load1[1h])

# QUANTILE_OVER_TIME - Percentil no per√≠odo
quantile_over_time(0.95, http_request_duration_seconds[1h])
quantile_over_time(0.5, node_load1[1h])  # Mediana
```

### **üéØ Casos de Uso Pr√°ticos**

```promql
# === AN√ÅLISE DE PERFORMANCE ===
# Pico de CPU na √∫ltima hora
max_over_time((100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100))[1h:])

# Lat√™ncia m√©dia na √∫ltima hora
avg_over_time(histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))[1h:])

# Variabilidade da lat√™ncia (alta = inst√°vel)
stddev_over_time(histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))[1h:])

# === AN√ÅLISE DE CAPACIDADE ===
# Uso m√°ximo de mem√≥ria no dia
max_over_time((1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes))[1d:])

# Tr√°fego m√©dio de rede na semana
avg_over_time(rate(node_network_receive_bytes_total[5m])[1w:])

# === AN√ÅLISE DE DISPONIBILIDADE ===
# Uptime m√©dio na √∫ltima semana
avg_over_time(up[1w]) * 100

# N√∫mero de falhas no √∫ltimo m√™s
count_over_time((up == 0)[1M:])

# Tempo total de downtime no dia (em minutos)
(count_over_time((up == 0)[1d:]) * 15) / 60  # Assumindo scrape_interval=15s
```

---

## üîó OPERA√á√ïES ENTRE M√âTRICAS (JOINS)

### **üéØ Matching de Labels**

```promql
# === ON - Especifica labels para matching ===
# CPU usage com informa√ß√µes de mem√≥ria
(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)
) 
and on(instance) 
(
  (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
)

# Requisi√ß√µes por segundo com lat√™ncia
rate(http_requests_total[5m])
and on(instance, job)
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

# === IGNORING - Ignora labels espec√≠ficos ===
# Comparar m√©tricas ignorando labels irrelevantes
node_memory_MemTotal_bytes
and ignoring(cpu, mode)
node_cpu_seconds_total
```

### **üîÑ Tipos de Join**

```promql
# === ONE-TO-ONE (padr√£o) ===
node_memory_MemTotal_bytes
and on(instance)
node_memory_MemAvailable_bytes

# === ONE-TO-MANY ===
# Informa√ß√µes de servidor com m√©tricas de CPU por core
node_uname_info
and on(instance) group_left(nodename, release)
node_cpu_seconds_total

# === MANY-TO-ONE ===
# M√©tricas de aplica√ß√£o com informa√ß√µes do servidor
http_requests_total
and on(instance) group_right(version, release)
node_uname_info

# === GROUP_LEFT/GROUP_RIGHT com labels ===
# Adicionar informa√ß√µes do servidor √†s m√©tricas de aplica√ß√£o
rate(http_requests_total[5m])
and on(instance) group_left(nodename, machine)
node_uname_info
```

### **üéØ Exemplos Pr√°ticos de Joins**

```promql
# === CORRELA√á√ÉO CPU vs MEM√ìRIA ===
# Servidores com alta CPU E alta mem√≥ria
(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
)
and on(instance)
(
  (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
)

# === ENRIQUECIMENTO DE DADOS ===
# Adicionar informa√ß√µes do OS √†s m√©tricas de performance
(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
)
and on(instance) group_left(nodename, release, machine)
node_uname_info

# === AN√ÅLISE DE APLICA√á√ÉO ===
# Correlacionar erros HTTP com uso de recursos
rate(http_requests_total{status=~"5.."}[5m])
and on(instance) group_left
(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 70
)

# === CAPACIDADE vs DEMANDA ===
# Comparar uso atual com capacidade total
(
  rate(node_network_receive_bytes_total[5m]) / 1024 / 1024  # MB/s atual
)
and on(instance, device) group_left
(
  node_network_speed_bytes / 1024 / 1024  # Capacidade em MB/s
)
```

---

## üîÆ FUN√á√ïES DE PREDI√á√ÉO E AN√ÅLISE

### **üìà PREDICT_LINEAR**

```promql
# Predi√ß√£o de uso de disco em 4 horas
predict_linear(node_filesystem_free_bytes[1h], 4*3600)

# Predi√ß√£o de crescimento de mem√≥ria
predict_linear(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes[2h], 3600)

# Quando o disco ficar√° cheio (em segundos)
(
  node_filesystem_free_bytes - 
  predict_linear(node_filesystem_free_bytes[1h], 3600)
) / 
(
  predict_linear(node_filesystem_free_bytes[1h], 3600) - 
  predict_linear(node_filesystem_free_bytes[1h], 0)
) * 3600

# Predi√ß√£o de requisi√ß√µes por hora
predict_linear(rate(http_requests_total[5m])[30m:], 3600) * 3600

# Crescimento esperado de conex√µes
predict_linear(mysql_global_status_threads_connected[1h], 2*3600)
```

### **üìä DERIV - Derivada**

```promql
# Taxa de mudan√ßa do uso de mem√≥ria
deriv(node_memory_MemAvailable_bytes[5m])

# Acelera√ß√£o do crescimento de requisi√ß√µes
deriv(rate(http_requests_total[5m])[10m:])

# Tend√™ncia de crescimento do load average
deriv(node_load1[10m])

# Velocidade de mudan√ßa do uso de disco
deriv((node_filesystem_size_bytes - node_filesystem_free_bytes)[5m])
```

### **üéØ An√°lises Preditivas Pr√°ticas**

```promql
# === ALERTAS PREDITIVOS ===
# Disco ficar√° cheio em menos de 4 horas
(
  predict_linear(node_filesystem_free_bytes[1h], 4*3600) < 0
) 
and 
(
  deriv(node_filesystem_free_bytes[1h]) < 0
)

# Mem√≥ria se esgotar√° em 2 horas
(
  predict_linear(node_memory_MemAvailable_bytes[30m], 2*3600) < 
  node_memory_MemTotal_bytes * 0.05  # Menos de 5%
)
and
(
  deriv(node_memory_MemAvailable_bytes[30m]) < 0
)

# === PLANEJAMENTO DE CAPACIDADE ===
# Crescimento esperado de tr√°fego em 1 semana
predict_linear(rate(node_network_receive_bytes_total[1d])[7d:], 7*24*3600)

# Proje√ß√£o de conex√µes de banco em 24h
predict_linear(mysql_global_status_threads_connected[2h], 24*3600)

# === DETEC√á√ÉO DE ANOMALIAS ===
# Desvio da tend√™ncia normal (crescimento an√¥malo)
abs(
  rate(http_requests_total[5m]) - 
  predict_linear(rate(http_requests_total[5m])[1h:], 0)
) > 
stddev_over_time(rate(http_requests_total[5m])[1h:]) * 2
```

---

## üîç FUN√á√ïES DE AN√ÅLISE TEMPORAL

### **‚è™ OFFSET - Compara√ß√£o Temporal**

```promql
# Comparar com 1 hora atr√°s
node_load1 - node_load1 offset 1h

# Comparar com mesmo hor√°rio ontem
rate(http_requests_total[5m]) - rate(http_requests_total[5m]) offset 1d

# Comparar com semana passada
node_memory_MemAvailable_bytes - node_memory_MemAvailable_bytes offset 1w

# Crescimento percentual em rela√ß√£o a ontem
(
  rate(http_requests_total[5m]) - 
  rate(http_requests_total[5m]) offset 1d
) / 
rate(http_requests_total[5m]) offset 1d * 100

# Varia√ß√£o de CPU em rela√ß√£o √† hora anterior
(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)
) - 
(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100) offset 1h
)
```

### **üìÖ An√°lises Sazonais**

```promql
# === COMPARA√á√ïES DI√ÅRIAS ===
# Tr√°fego atual vs mesmo hor√°rio ontem
rate(http_requests_total[5m]) / rate(http_requests_total[5m]) offset 1d

# Diferen√ßa de load em rela√ß√£o a ontem
node_load1 - node_load1 offset 1d

# === COMPARA√á√ïES SEMANAIS ===
# Performance atual vs semana passada
(
  histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))
) / (
  histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) offset 1w
)

# === DETEC√á√ÉO DE PADR√ïES ===
# Identificar picos an√¥malos (>50% acima do normal)
(
  rate(http_requests_total[5m]) > 
  rate(http_requests_total[5m]) offset 1d * 1.5
)
and
(
  rate(http_requests_total[5m]) > 
  avg_over_time(rate(http_requests_total[5m])[1d:]) * 1.5
)
```

---

## üßÆ FUN√á√ïES MATEM√ÅTICAS AVAN√áADAS

### **üìä Fun√ß√µes Estat√≠sticas**

```promql
# === CLAMP - Limitar valores ===
# Limitar CPU entre 0 e 100
clamp(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100),
  0, 100
)

# Limitar lat√™ncia m√°xima
clamp_max(
  histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])),
  10  # M√°ximo 10 segundos
)

# Limitar valor m√≠nimo
clamp_min(node_load1, 0)

# === SORT - Ordena√ß√£o ===
# Ordenar por valor (crescente)
sort(node_load1)

# Ordenar por valor (decrescente)
sort_desc(node_load1)

# === ABSENT - Detectar m√©tricas ausentes ===
# Alertar se m√©trica n√£o existe
absent(up{job="critical-service"})

# Alertar se n√£o h√° requisi√ß√µes
absent(rate(http_requests_total[5m]))

# Verificar se target espec√≠fico est√° ausente
absent(up{instance="critical-server:9100"})
```

### **üî¢ Transforma√ß√µes Matem√°ticas**

```promql
# === SGML - Sinal ===
# Detectar tend√™ncia (positiva/negativa/zero)
sgn(deriv(node_memory_MemAvailable_bytes[5m]))

# === RESETS - Detectar resets de counter ===
# Quantos resets teve um counter
resets(http_requests_total[1h])

# === CHANGES - Detectar mudan√ßas ===
# Quantas vezes o valor mudou
changes(up[1h])

# === HOLT_WINTERS - Suaviza√ß√£o exponencial ===
# Predi√ß√£o com sazonalidade
holt_winters(rate(http_requests_total[5m])[1h:], 0.3, 0.3)

# Suaviza√ß√£o de m√©tricas ruidosas
holt_winters(node_load1[30m:], 0.5, 0.5)
```

---

## üéØ QUERIES COMPLEXAS PARA TROUBLESHOOTING

### **üö® Detec√ß√£o de Anomalias**

```promql
# === ANOMALIAS DE PERFORMANCE ===
# CPU anormalmente alto (>3 desvios padr√£o)
(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)
) > (
  avg_over_time((100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100))[1h:]) +
  3 * stddev_over_time((100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100))[1h:])
)

# Lat√™ncia an√¥mala (P95 > m√©dia + 2*stddev)
histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) >
(
  avg_over_time(histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))[1h:]) +
  2 * stddev_over_time(histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))[1h:])
)

# === CORRELA√á√ÉO DE PROBLEMAS ===
# Servidores com problemas m√∫ltiplos
(
  # Alta CPU
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
)
and on(instance)
(
  # Alta mem√≥ria
  (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
)
and on(instance)
(
  # Alto load
  node_load1 > 2
)

# === DETEC√á√ÉO DE GARGALOS ===
# Endpoints com alta lat√™ncia E alto volume
(
  histogram_quantile(0.95, sum by(endpoint, le) (rate(http_request_duration_seconds_bucket[5m]))) > 1
)
and on(endpoint)
(
  sum by(endpoint) (rate(http_requests_total[5m])) > 10
)
```

### **üìä An√°lise de Capacidade**

```promql
# === UTILIZA√á√ÉO DE RECURSOS ===
# Score de utiliza√ß√£o geral do servidor (0-100)
(
  # CPU (peso 30%)
  (100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)) * 0.3 +
  # Mem√≥ria (peso 30%)
  ((1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100) * 0.3 +
  # Disco (peso 25%)
  ((1 - (node_filesystem_free_bytes{fstype!="tmpfs"} / node_filesystem_size_bytes{fstype!="tmpfs"})) * 100) * 0.25 +
  # Load (peso 15%)
  (node_load1 / on(instance) group_left count by(instance) (node_cpu_seconds_total{mode="idle"})) * 100 * 0.15
)

# === RANKING DE PERFORMANCE ===
# Top servidores por score de performance
topk(10,
  # Lat√™ncia de disco (peso 40%)
  (rate(node_disk_io_time_seconds_total[5m]) * 100) * 0.4 +
  # CPU wait (peso 30%)
  (rate(node_cpu_seconds_total{mode="iowait"}[5m]) * 100) * 0.3 +
  # Load average (peso 30%)
  (node_load1 / on(instance) group_left count by(instance) (node_cpu_seconds_total{mode="idle"})) * 100 * 0.3
)

# === PREVIS√ÉO DE SATURA√á√ÉO ===
# Recursos que atingir√£o 90% em 2 horas
(
  predict_linear(
    (1 - (node_filesystem_free_bytes{fstype!="tmpfs"} / node_filesystem_size_bytes{fstype!="tmpfs"})) * 100
    [1h], 2*3600
  ) > 90
)
and
(
  deriv(
    (1 - (node_filesystem_free_bytes{fstype!="tmpfs"} / node_filesystem_size_bytes{fstype!="tmpfs"})) * 100
    [1h]
  ) > 0
)
```

### **üîç An√°lise de Padr√µes**

```promql
# === DETEC√á√ÉO DE CICLOS ===
# Varia√ß√£o c√≠clica de CPU (detectar padr√µes)
stddev_over_time(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)
  [1h:]
) / 
avg_over_time(
  100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100)
  [1h:]
)

# === AN√ÅLISE DE TEND√äNCIAS ===
# Crescimento sustentado (3 pontos consecutivos crescendo)
(
  rate(http_requests_total[5m]) > rate(http_requests_total[5m]) offset 5m
)
and
(
  rate(http_requests_total[5m]) offset 5m > rate(http_requests_total[5m]) offset 10m
)
and
(
  rate(http_requests_total[5m]) offset 10m > rate(http_requests_total[5m]) offset 15m
)

# === DETEC√á√ÉO DE OUTLIERS ===
# Servidores com comportamento at√≠pico
abs(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) -
  avg(100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))
) > 
2 * stddev(100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))
```

---

## ‚ö° OTIMIZA√á√ÉO DE PERFORMANCE

### **üöÄ Boas Pr√°ticas**

```promql
# ‚ùå EVITAR - Query muito ampla
{__name__=~".*"}

# ‚úÖ PREFERIR - Query espec√≠fica
node_cpu_seconds_total{mode="idle"}

# ‚ùå EVITAR - Regex complexa desnecess√°ria
http_requests_total{endpoint=~".*api.*v1.*users.*"}

# ‚úÖ PREFERIR - Labels espec√≠ficos
http_requests_total{service="api", version="v1", resource="users"}

# ‚ùå EVITAR - Ranges muito longos sem necessidade
rate(http_requests_total[1d])

# ‚úÖ PREFERIR - Range apropriado
rate(http_requests_total[5m])

# ‚ùå EVITAR - M√∫ltiplas agrega√ß√µes desnecess√°rias
sum(avg(max(node_load1)))

# ‚úÖ PREFERIR - Agrega√ß√£o direta
avg(node_load1)
```

### **üìä T√©cnicas de Otimiza√ß√£o**

```promql
# === USAR RECORDING RULES ===
# Em vez de repetir esta query complexa:
histogram_quantile(0.95, 
  sum by(job, endpoint, le) (
    rate(http_request_duration_seconds_bucket[5m])
  )
)

# Criar recording rule:
# groups:
# - name: http_latency
#   rules:
#   - record: http:request_duration_seconds:p95
#     expr: histogram_quantile(0.95, sum by(job, endpoint, le) (rate(http_request_duration_seconds_bucket[5m])))

# Usar a recording rule:
http:request_duration_seconds:p95

# === FILTRAR CEDO ===
# ‚ùå Filtrar depois da agrega√ß√£o
sum(rate(http_requests_total[5m])) and on() (up{job="web"} == 1)

# ‚úÖ Filtrar antes da agrega√ß√£o
sum(rate(http_requests_total{job="web"}[5m]))

# === USAR SUBQUERIES EFICIENTEMENTE ===
# ‚ùå Subquery desnecess√°ria
avg_over_time(rate(http_requests_total[5m])[1h:])

# ‚úÖ Fun√ß√£o direta quando poss√≠vel
avg_over_time(increase(http_requests_total[5m])[1h:]) / 300  # 5m = 300s
```

---

## üß™ EXERC√çCIOS AVAN√áADOS

### **üéØ Exerc√≠cio 1: An√°lise Preditiva**

```promql
# 1. Prediga quando o disco /var ficar√° cheio
predict_linear(
  node_filesystem_free_bytes{mountpoint="/var"}[2h], 
  4*3600
) < 0

# 2. Detecte crescimento an√¥malo de mem√≥ria
deriv(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes[1h]) >
2 * stddev_over_time(
  deriv(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes[1h])[1d:]
)

# 3. Preveja pico de tr√°fego baseado em tend√™ncia
predict_linear(rate(http_requests_total[5m])[1h:], 2*3600) >
max_over_time(rate(http_requests_total[5m])[1w:]) * 1.5
```

### **üéØ Exerc√≠cio 2: Correla√ß√£o de M√©tricas**

```promql
# 1. Encontre servidores com alta CPU correlacionada com alta lat√™ncia
(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 70
)
and on(instance) group_left
(
  avg by(instance) (histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))) > 1
)

# 2. Identifique aplica√ß√µes com erros correlacionados com recursos
rate(http_requests_total{status=~"5.."}[5m])
and on(instance) group_left
(
  (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 85
)

# 3. Compare performance atual com semana passada
(
  histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))
) / (
  histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) offset 1w
) > 1.3  # 30% pior que semana passada
```

### **üéØ Exerc√≠cio 3: Detec√ß√£o de Anomalias**

```promql
# 1. Detecte outliers de CPU (>2 desvios padr√£o)
abs(
  100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) -
  avg(100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))
) > 
2 * stddev(100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))

# 2. Identifique padr√µes an√¥malos de requisi√ß√µes
abs(
  rate(http_requests_total[5m]) - 
  avg_over_time(rate(http_requests_total[5m])[1h:])
) > 
3 * stddev_over_time(rate(http_requests_total[5m])[1h:])

# 3. Detecte mudan√ßas bruscas de comportamento
abs(
  rate(http_requests_total[5m]) - 
  rate(http_requests_total[5m]) offset 15m
) > 
stddev_over_time(rate(http_requests_total[5m])[1h:]) * 2
```

---

## üéì RESUMO DO M√ìDULO

### **Conceitos Avan√ßados Aprendidos:**
- ‚úÖ **Agrega√ß√£o temporal:** _over_time functions
- ‚úÖ **Joins complexos:** on, ignoring, group_left/right
- ‚úÖ **Predi√ß√£o:** predict_linear, deriv, holt_winters
- ‚úÖ **An√°lise temporal:** offset, compara√ß√µes sazonais
- ‚úÖ **Detec√ß√£o de anomalias:** outliers, padr√µes an√¥malos
- ‚úÖ **Otimiza√ß√£o:** performance, recording rules

### **Pr√≥ximos Passos:**
1. üö® **[M√≥dulo 07: Regras de Alerta](07-regras-alerta.md)** - Alertas inteligentes
2. üõ†Ô∏è **[M√≥dulo 08: Troubleshooting](08-troubleshooting.md)** - Resolu√ß√£o de problemas
3. üìä **[M√≥dulo 09: Integra√ß√£o Grafana](09-integracao-grafana.md)** - Visualiza√ß√µes

---

**üìö M√≥dulo Anterior:** [05 - PromQL B√°sico](05-promql-basico.md)  
**üìö Pr√≥ximo M√≥dulo:** [07 - Regras de Alerta](07-regras-alerta.md)  
**üè† Voltar ao:** [README Principal](README.md)

---

*M√≥dulo criado pela comunidade DevOps*  
*√öltima atualiza√ß√£o: Janeiro 2025*